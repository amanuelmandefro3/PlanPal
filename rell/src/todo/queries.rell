query get_tasks(
    user_id: byte_array,
    pointer: integer,
    n_tasks: integer,
    sort: text
): (total: integer, pointer: integer,  todos: list<todo_dto>) {
    val user = require_user(user_id);
    val total = todo @* { todo.user == user } ( @ sum 1 )[0];
    if (sort == "ASC") {
        val todos = todo @* { todo.user == user } (
            @sort @omit todo.due_date,
            todo_dto (
                .rowid,
                .title,
                .description,
                .status,
                .due_date,
                user = todo.user.to_struct()
            )
        ) offset pointer limit n_tasks;
        return (
            total = total,
            pointer = pointer + todos.size(),
            todos = todos
        );
    } else {
        val todos = todo @* { todo.user == user } (
            @sort_desc @omit todo.due_date,
            todo_dto (
                .rowid,
                .title,
                .description,
                .status,
                .due_date,
                user = todo.user.to_struct()
            )
        ) offset pointer limit n_tasks;

        return (
            total = total,
            pointer = pointer + todos.size(),
            todos = todos
        );
    }
}

query get_today_tasks(
    user_id: byte_array,
    day_start: timestamp,
    day_end: timestamp,
    pointer: integer,
    n_tasks: integer,
): (total:integer, pointer: integer, todos: list<todo_dto> ) {
    val user = require_user(user_id);
    // val current_time: timestamp = context.last_block_time;
    // val start_timestamp: timestamp = current_time - (current_time % 86400000);
    // val end_timestamp: timestamp = start_timestamp + 86400000 - 1;

    val todos = todo @* { todo.user == user, todo.due_date >= day_start, todo.due_date <= day_end } (
        @sort @omit todo.due_date,
        todo_dto (
            .rowid,
            .title,
            .description,
            .status,
            .due_date,
            user = todo.user.to_struct()
        )
    ) offset pointer limit n_tasks;

    val total = todo @* { todo.user == user, todo.due_date >= day_start, todo.due_date <= day_end } ( @ sum 1 )[0];

    return (
        total = total,
        pointer = pointer + todos.size(),
        todos = todos
    );
}

query get_task(
    user_id: byte_array,
    task_id: integer
): todo_dto {
    val user = require_user(user_id);
    val todo = todo @ { .rowid == rowid(task_id), todo.user == user } (
        todo_dto (
            .rowid,
            .title,
            .description,
            .status,
            .due_date,
            user = todo.user.to_struct()
        )
    );

    return todo;
}

query get_task_by_status(
    user_id: byte_array,
    status_front: text,
    pointer: integer,
    n_tasks: integer
): (total: integer, pointer: integer, todos: list<todo_dto>) {

    val user = require_user(user_id);

    if (status_front == "PENDING") {
        print("I am here flag it out ");
        val todos = todo @* { todo.user == user, todo.status == status.PENDING } (
            @sort @omit todo.due_date,
            todo_dto (
                .rowid,
                .title,
                .description,
                .status,
                .due_date,
                user = todo.user.to_struct()
            )
        ) offset pointer limit n_tasks;

        val total = todo @* { todo.user == user, todo.status == status.PENDING } ( @ sum 1 )[0];

        return (
            total = total,
            pointer = pointer + todos.size(),
            todos = todos
        );
    } else {
        val todos = todo @* { todo.user == user, todo.status == status.COMPLETED } (
            @sort @omit todo.due_date,
            todo_dto (
                .rowid,
                .title,
                .description,
                .status,
                .due_date,
                user = todo.user.to_struct()
            )
        ) offset pointer limit n_tasks;

        val total = todo @* { todo.user == user, todo.status == status.COMPLETED } ( @ sum 1 )[0];

        return (
            total = total,
            pointer = pointer + todos.size(),
            todos = todos
        );
    }
}

query get_task_upcoming_days(
    user_id: byte_array,
    next_day: integer,
    pointer: integer,
    n_tasks: integer,
): (total: integer, pointer: integer, todos: list<todo_dto>) {
    val user = require_user(user_id);
    val todos = todo @* { todo.user == user, todo.due_date >= next_day } (
        @sort @omit todo.due_date,
        todo_dto (
            .rowid,
            .title,
            .description,
            .status,
            .due_date,
            user = todo.user.to_struct()
        )
    ) offset pointer limit n_tasks;

    val total = todo @* { todo.user == user, todo.due_date >= next_day } ( @ sum 1 )[0];

    return (
        total = total,
        pointer = pointer + todos.size(),
        todos = todos
    );
}
